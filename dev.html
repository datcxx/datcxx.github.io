<head>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro&display=swap" rel="stylesheet">
  <link href="index.css" rel="stylesheet">
</head>

<header>
  <meta name="description" content="C++ DAT">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1 user-scalable=no">
  <img src="https://avatars2.githubusercontent.com/u/8672221?s=150&v=4"/>
  <h1>C++ DAT</h1>
  <nav>
    <a href="index.html">FAQ</a>
    <a href="api.html">API</a>
    <a href="dev.html" class="selected">Development</a>
  </nav>
</header>

<main>
  <h2>Contributing Guidelines</h2>

  <ul>
    <li>All commits should make
      <a href="https://clang.llvm.org/extra/clang-tidy/">clang-tidy</a>
      happy.</h2></li>
    <li>Use <a href="https://github.com/heapwolf/cxx-tap">tap</a> for
    testing.</li>
    <li>Use <a href="http://github.com/datcxx/hyper-docs">hyper-docs</a>
    to generate documentation.
    <li>For benchmarking fun use <a href="http://quick-bench.com/">this</a>.
    <li>Almost never use <b>new</b> keyword. If absolutely requied, handle with shared or unique.
  </ul>

  <h2>Signed packages</h2>

  <p>Releases can be verified using the
    <a href="https://jedisct1.github.io/minisign/">minisign</a> tool.
  </p>

  <pre><code>
  $minisign -Vm <file> -P RWRp6fDk3xmMR66imdmX9Pc9VLcwKaGrpgW6SqW6rWMRPZ6NBiC5bD3e
  </code></pre>

  <h2>Build System &amp; Package Manager</h2>

  <p>
    Tools that solve problems you don't have slow down your productivity.
    We created <a href="https://github.com/datcxx/build">this</a> crude and
    simple solution. It does not (and doesn't need to)...
  </p>
  
  <ul>
    <li>provide high-performance caching optimizations</li>
    <li>provide a configuration language or DSL</li>
  </ul>

  <p>
    It does...
  </p>

  <ul>
    <li>Use a strict subset of the well known <b>package.json</b> format</li>
    <li>Use a well-defined location to place dependency trees (./deps)</li>
  </ul>

  <h3>Requirements</h3>

  <pre><code>
  clang++ &gt;= 8.0
  node.js &gt;= 12
  git &gt;= 2.0
  </code></pre>

  <h3>Usage</h3>

  <pre><code>
  $build -h

    build v2.0.0

    build [...args]                   build the project [with ...args]
    build -h|help                     print this help screen
    build -i|install [dep]            recursively install dep(s)
    build -u|upgrade [dep]            recursively upgrade dep(s)
    build add &lt;remote&gt; [hash] [-d]    add git dep [at commit] [as dev]
    build init                        initialze a new project
    build run &lt;name&gt;                  run a sepecific script
    build test                        run the test script
  </code></pre>

  <h3>Dependencies</h3>

  <p>
    Becase dependencies are in a well known location, and each one contains a
    <b>package.json</b> file, sources and headers can be discovered and easily
    passed to the compiler.
  </p>

  <h3>Test and build commands</h3>

  <p>
    The <b>test</b> and <b>build</b> command will recursively find all
    dependency files and flags, dedupe them and pass them to the compiler.
    This is sufficiant and works well for all cases in this project.
  </p>

  <h2>Hypercore</h2>
    <ul>
      <li>path 100%</li>
      <li>varint 100%</li>
      <li>eventemitter 100%</li>
      <li>flat-tree 100%</li>
      <li>count-trailing-zeros 100%</li>
      <li>buffer 100%</li>
      <li>memory-pager 80%</li>
      <li>sparse-bitfield 80%</li>
      <li>merkle-tree-stream 10%</li>
    </ul>
  <h3 id="topology">Hypercore module topology</h2>
  <a class="image-link" href="hypercore.svg">
    <img class="topology" src="hypercore.svg"/>
  </a>

  <h2>Hyperdrive</h2>
    <ul>
      <li>hypercore</li>
      <li>append-tree</li>
      <li>random-access-file</li>
    </ul>
  <h2>Dat</h2>
    <ul>
      <li>hyperdrive</li>
    </ul>

</main>
